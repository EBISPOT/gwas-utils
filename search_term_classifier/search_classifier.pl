#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use URI::Encode;
use JSON;
use Getopt::Long qw(GetOptions);

# Initialize URI encoder object (to decode URI encoded search terms):
our $uri = URI::Encode->new( { encode_reserved => 0 } );

# Initialize command line parameters:
my $traitFile= '';
my $ancestryFile = '';
my $geneFile = '';
my $logFile = '';
my $consortiaFile = '';
my $help = 0;

# Parsing command line arguments:
GetOptions ("traitFile|t=s" => \$traitFile,
            "ancestryFile|a=s" => \$ancestryFile,
            "geneFile|g=s" => \$geneFile,
            "logFile|l=s" => \$logFile,
            "consortiaFile|l=s" => \$consortiaFile,
            "help|h=s" => \$help)
  or display_help();

# Collection of tested classes:
our %Dispatch_table = (
    'variant' => \&is_variant,
    'trait'=> \&is_trait,
    'gene' => \&is_gene,
    'pmid' => \&is_pubmedId,
    'ancestry' => \&is_ancestry,
    'cytoband' => \&is_cytological_band,
    'consortia' => \&is_consortia,
    'region' => \&is_region,
    'study' => \&is_study,
    'author' => \&is_author
);

# Reading phenotype terms:
our $traitDefinitions = read_term_lists($traitFile);
printf STDERR ("[Info] Number of trait related terms: %s\n", scalar keys %{$traitDefinitions});

# Reading gene terms:
our $geneDefinitions = read_term_lists($geneFile);
printf STDERR ("[Info] Number of gene related terms: %s\n", scalar keys %{$geneDefinitions});

# Reading ancestry related terms:
our $ancestryDefinitions = read_term_lists($ancestryFile);
printf STDERR ("[Info] Number of ancestry related terms: %s\n", scalar keys %{$ancestryDefinitions});

# Reading phenotype terms:
our $consortiaDefinitions = read_term_lists($consortiaFile);
printf STDERR ("[Info] Number of consortia related terms: %s\n", scalar keys %{$consortiaDefinitions});

# Exclusion list. Contents of this hash will be excluded from the summary:
# (These terms are listed under the search bar so users often click on them)
my %exclusion_list = (
    'breast carcinoma' => 1,
    'rs7329174' => 1,
    'yao' => 1,
    '2q37.1' => 1,
    'hbs1l' => 1,
    '6:16000000-25000000' => 1
);

# Initialize parameters:
my $fileHandles = generate_fileHandles(keys %Dispatch_table);
my %class_overlap = ();
my %classification = ();

# Keep track of some of the counts:
my $all_query_count =0;
my $all_term_count = 0;
my $excluded_count = 0;
my $unclassified_count = 0;
my $unclassified_term_count = 0;

# Open file with search terms - generated by the log-parser scripts
open my $LOGFILE, "<", $logFile;
while ( my $line = <$LOGFILE> ){
    chomp $line;

    # Pre-process search term:
    my ($count, $term) = split(/\t/,$line);
    my $clean_term = clean_text($term);

    # Exclude term if it is in the exclusion list:
    if (exists $exclusion_list{$clean_term}){
        $excluded_count += $count;
        next;
    }

    # Keeping track of the number of queries:
    $all_query_count += $count;
    $all_term_count ++;

    # What are the assigned terms:
    my $classes = classify_term($clean_term);

    # How many classes were assigned:
    my $classCount = scalar @{$classes};

    # Dealing with unclassified terms:
    if ($classes->[0] eq 'unclassified'){

        # Add to class overlap:
        $class_overlap{0}{'count'} += $count;
        $class_overlap{0}{'term'} ++;

        # Count unclassified terms:
        $unclassified_count += $count;
        $unclassified_term_count ++;
    }
    else {

        # Add to class overlap:
        $class_overlap{$classCount}{'count'} += $count;
        $class_overlap{$classCount}{'term'} ++;
    }


    # Saving term to all assigned classes:
    foreach my $class (@{$classes}){

        # Counting queries for each terms:
        $classification{$class} += $count;

        # Saving term for each associated class:
        printf { $fileHandles->{$class} } "%s\t%s\t%s\n", $count, $clean_term, join(", ", @{$classes});
    }

}

# Print summary of the classification:
printf "\n[Info] Number of search summarized: %s\n", $all_query_count;
printf "[Info] Number of excluded searches: %s\n", $excluded_count;
printf "[Info] Number of search terms: %s\n", $all_term_count;
printf "[Info] Number of terms that could not be classified: %s (%.1f%%), representing %s (%.1f%%) searches.\n", ( $unclassified_term_count, ($unclassified_term_count/$all_term_count *100), 
    $unclassified_count, ($unclassified_count/$all_query_count)*100);


# Report counts for all the queries:
print "\n[Info] reporting the distribution of searches across all classes:\n";
foreach my $class (keys %classification){
    printf "%-12s - %-7s (%.2f%%)\n", $class, $classification{$class}, $classification{$class} / $all_query_count * 100
}

# Report the overlapping of the classes:
print "\n[Info] The following table shows the abmiguity of the classification.\n";
print "[Info] It shows how many of the terms, and searches were classified into 0,1,2 or more casses.\n";
print "Assigned_class\tTerms\tSearch_count\n";
foreach my $count (sort {$a <=> $b} keys %class_overlap){
    printf "%s\t%s\t%s\n", $count, $class_overlap{$count}{'term'}, $class_overlap{$count}{'count'};
}

##
## Functions
##

# Each classified terms are saved in the corresponding class file:
sub generate_fileHandles {
    my @classes = @_;
    push @classes, 'unclassified';
    my $filePostfix = "_type.txt";
    my %handles = ();

    foreach my $class (@classes){
        open my $h, ">", $class . $filePostfix;
        $handles{$class} = $h;
    }

    return \%handles;
}

# Function to read a list from a file provided as input and returns a hashref
sub read_term_lists {
    my $fileName = shift;

    # Testing files:
    if ( not defined $fileName ){
        die "[Error] Term list file is not defined. Exiting.";
    }
    elsif ( not -e $fileName ){
        die "[Error] Term list file could not be opened.";
    }

    # Opening file:
    my %hash = ();
    open my $TERMFILE, "<", $fileName;
    while (my $line = <$TERMFILE>){
        chomp $line;
        $line = lc $line;
        $hash{$line} ++;
    }

    return \%hash;
}

# A collection of steps to clean the search term:
sub clean_text {
    my $term = $_[0];

    # Decode uri:
    my $decodedTerm = $uri->decode($term);

    # Remove leading and trailing whitespace:
    $decodedTerm =~ s/^\s*|\s*$//g;

    # Replace + sign with space:
    $decodedTerm =~ s/\+/ /g;

    # Remove a commonly found string:
    $decodedTerm =~ s/\*\&filter=//g;

    # Returned cleaned term:
    return(lc $decodedTerm) 
}

# Test if a term is a variant or not:
sub is_variant{
    my $term = $_[0];
    
    $term =~ s/\s//g;
    
    # Matching frequently used variant identifiers:
    if ($term =~ /rs\d{3,}/i ||
        $term =~ /exm\d+/i ||
        $term =~ /kgp\d+/i ||
        $term =~ /[xy\d]+:\d+[^-]/ ){
        return 1;
    }
}

# Test if a term is a trait or not:
sub is_trait{
    my $term = $_[0];

    # EFO IDs are considered traits:
    if ($term =~ /efo.\d+/i){
        return 1;
    }

    # Considering exact matches only
    if ( exists $traitDefinitions->{$term} ){
        return 1;
    }
}

# Test if a term is a gene or not:
sub is_gene{
    my $term = $_[0];
    
    # Test if a term is a perfect match with a gene name/identifier/synonym:
    if ( exists $geneDefinitions->{$term} ){
        return 1;
    }

    # Gene card gene identifier:
    elsif ( $term =~ /gc[\dxy]+[a-z][\d]+/){
        return 1;
    }

    # Is Ensembl gene ID provided:
    elsif ( $term =~ /ensg\d+/){
        return 1;
    }
}

# Test if a term is a pubmedID or not:
sub is_pubmedId {
    my $term = $_[0];
    $term =~ s/[\s,]//g;

    # Excluding variant IDs, gene IDs and Chr:pos definitions
    if ( $term =~ /[^\d]*[1-3]\d{7}[^\d]*/i && 
         $term !~ /rs\d+|kgp\d+|exm\d+|[xy\d]:\d+/){
        return 1;
    }
}

# Test if a GWAS Catalog study is directly requested:
sub is_study {
    my $term = $_[0];
    if ( $term =~ /gcst\d+/i){
        return 1;
    }
}

# Test if a term is a cytological band:
sub is_cytological_band {
    my $term = $_[0];
    if ( $term =~ /^[\dxy]+[pq][\d]+/ ){
        return 1;
    }
}

# Test if a term is a genomic region
sub is_region {
    my $term = $_[0];
    $term =~ s/\s|,//g;
    if ( $term =~ /[xy\d]+:[1-9]\d+.+-\d+/){
        return 1;
    }
}

# Test if a term is classified as consortia/dataset 
sub is_consortia {
    my $term = $_[0];

    # Looking for exact match:
    if ( exists $consortiaDefinitions->{$term} ){
        return 1;
    }
    # It is OK if found the word consortia in the term:
    elsif ( ($term =~ /consort/ || $term =~ /biobank/) && length($term) < 50 ){
        return 1;
    }
}

# Test if ancestry related
sub is_ancestry {
    my $term = $_[0];

    # Considered only perfect match:
    if ( exists $ancestryDefinitions->{$term} ){
        return 1;
    }
}

# Test if author is queried:
sub is_author {
    my $term = $_[0];
    if ( $term !~ /vitamin|hepatitis|cystatin|apolipoprotein/ && $term =~ /\w\s+\D{1,2}$/ ){
        return 1;
    }
}

# A function to return the classes a given search term was classified into:
sub classify_term {

    my $term = $_[0];
    my $selected_classes = [];

    # Looping through all classes and check which one is true:
    foreach my $class (keys %Dispatch_table){
        push @{$selected_classes}, $class if $Dispatch_table{$class}->($term);
    }

    # Return the selected classes:
    return ( scalar @{$selected_classes} > 0 ) ? $selected_classes : ["unclassified"];
}

# A standard help message to guide users to troubleshoot.
sub display_help {
    my $error_message = shift;

    ## TODO: improve help message.

    my $standard_message = "

This script was written to parse GWAS Catalog search terms and to classify into major categories: publication title, author, pmid, gene, variant, region, trait etc.

Usage:

$0 -geneFile <gene file> \
    -traitFile <trait file> \
    -ancestryFile <ancestry file> \
    -consortiaFile <consortia file> \
    -logFile <log file>

Where: 
    trait file     - Collection of trait terms agains with the search term will be compared.
    gene file      - Collection of gene names/synonyms.
    ancestry file  - Collection of ancestry related terms.
    consortia file - Collection of genomic consortia.

    log file       - This the processed tomcat accesslog containing search terms and the search count.


Output:
    - Text output to the std output provides summaries of the classification.
    - Files for each classes generated to list all the classified terms and the corresponding numbers.

";

    die $error_message . $standard_message;

}



